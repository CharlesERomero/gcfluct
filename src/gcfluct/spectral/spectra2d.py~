import numpy as np
import UtilityFunctions as UF
import scipy.special as sps
import astropy.units as u
from astropy.units import Quantity
from typing import Union, List, Optional
from numpy.typing import NDArray, ArrayLike

class PSfromImages:

    def __init__(self,img,pixsize,pixunits,center=None,intrinsic_mask=None,img2=None,kpcperarcsec=0.0):
        """

        Parameters
        ----------
        img : NDArray[np.floating]
        center : Optional[ArrayLike[np.floating]]] 
        intrinsic_mask : Optional[NDArray[np.floating]] 
        img2 : Optional[NDArray[np.floating]]
        kpcperarcsec : np.floating
            Scale, i.e. physical distance (in kpc) per angle (arcseconds). Defaults to 0 (unphysical),
            so the value is defined, but it will not try to convert units.
        """

        self.imsz = img.shape
        self.pixsize = pixsize
        
        ### NB, yes astropy has the @u.quantity_input decorator, but I would have to define
        ### an equivalence between angle and length, which requires additional information
        ### that defeats the simplest use-case for this. So, I approach it this way.
        if isinstance(pixunits,Quantity): # Astropy quantity.
            # unitless angle conversion is risky; I will not accommodate it
            isAngle = pixunits.unit.is_equivalent(u.arcsec) # Explicit angle
            isLength = pixunits.unit.is_equivalent(u.kpc) # Explicit length
            if isAngle or isLength:
                self.pixunits = pixunits
            else:
                raise u.UnitTypeError("Pixel units must be (explicitly) an angle or length.")
        else:
            raise ValueError("Pixel units must be an angle or length.")
        
        self.mask_by_bin = np.ones(self.imsz)
        self.update_img(img,img2=img2)
        self.set_intrinsic_mask(intrinsic_mask)
        self.set_center(center=center)
        self.set_waveNumbers()

    def _set_pixunits(self,pixunits):
    
    def update_img(self,img,img2=None):

        self.img = img.astype(np.float64)
        self.img2 = None if img2 is None else img2.astype(np.float64)
        
    def set_center(self,center=None):

        if center is None:
            self.center  = [npix/2 for npix in self.imsz]
        else:
            self.center = center

        self._set_xyrmat()
            
    def _set_xyrmat(self):
        
        xvec=np.arange(self.imsz[0])
        yvec=np.arange(self.imsz[1])
        self.xmat=np.repeat([xvec],self.imsz[1],axis=0).transpose()
        self.ymat=np.repeat([yvec],self.imsz[0],axis=0)
        self.rmat=np.sqrt( (self.xmat-self.center[0])**2+(self.ymat-self.center[1])**2)*self.pixsize

    def set_intrinsic_mask(self,intrinsic_mask):

        self.intrinsic_mask = np.ones(self.imsz) if intrinsic_mask is None else intrinsic_mask

    def set_manual_mask_by_bin(self,mask_by_bin):

        self.mask_by_bin = mask_by_bin

    def set_annular_mask_by_bin(self,annular_edges):

        rcout = 0
        mask_by_bin = np.zeros(self.imsz)
        for rin,rout in zip(annular_edges[:-1],annular_edges[1:]):
            rcout += 1                    # Keep track of ring count
            imcopy = np.zeros(self.imsz)  # Make a copy of image
            imcopy[(rmat >= rin)]  = 1  # 
            imcopy[(rmat >= rout)] = 0  #
            mask_by_bin += imcopy * rcout
        self.mask_by_bin = mask_by_bin

    def set_waveNumbers(self,kmin=None,kmax=None,nkNode=None,kNode=None,padMax=3.0,padMin=2.0):

        k, dkx, dky = get_freqarr_2d(self.imsz[0],self.imsz[1],
                                     self.pixsize,self.pixsize)
        self.k_mat = k.astype(np.float64) # 2D matrix of k_r values corresponding to the image.

        if kNode is None:
            if kmin is None or kmax is None:
                self._SetDefaultkRange()
            else:
                self.kmin = kmin
                self.kmax = kmax
            NP2 = int(np.ceil(np.log(self.kmax/self.kmin)/np.log(2)))
            self.nkNode = NP2 if nkNode is None else nkNode
            self.A12_kn = np.logspace(np.log10(self.kmin),np.log10(self.kmax),self.nkNode)
        else:
            self.A12_kn = kNode # Nodes at which power spectrum is calculated
        self.r2a   = 3600.0 * 180.0 / np.pi # Number of arcseconds in a radian
        self.A12_pk = None
        self.FFT_kb = None # Bins within which power spectrum is averaged
        self.FFT_pk = None

    def _SetDefaultkRange(self,padMax=3.0,padMin=2.0):
        kmax = 1.0/(padMax*self.pixsize)
        gmean = np.sqrt(np.prod(self.imsz)) # Geometric mean of x- and y-axes (number of pixels)
        kmin = padMin/(gmean*self.pixsize)  #
        self.kmin = kmin
        self.kmax = kmax

    def PSviaFFT_2D_noMask(self,cross=False,corrN=True):

        imgfft = np.fft.fft2(self.img)*self.pixsize
        if cross and self.img2 is not None:
            imgfft2 = np.fft.fft2(self.img2)*self.pixsize
        else:
            imgfft2 = imgfft

        fftMag = np.abs(imgfft*imgfft2)
        imgps = fftMag / self.img.size if corrN else fftMag
        np2 = int(np.round(np.log(self.imsz[0])/np.log(2))*2.0) # No padding like for A12
        kb,pb,pe,pcnt = UF.bin_log2Ds(self.k_mat,imgps,nbins=np2,witherr=True,withcnt=True)
        self.FFT_kb = kb
        self.FFT_pk = pb
        
    def PSviaA12_2D(self,cross=False,cumBins=False):
        
        nBins = self.mask_by_bin.max() 
        self.A12_pk = np.zeros(self.A12_kn.shape+(nBins,))
        #mask =  np.zeros(self.imsz)

        for i in range(nBins):

            ### Construct mask for the bin. A bit excessive if mask_by_bin is all ones, but
            ### that case is not gauranteed! This generalizes the handling of the mask.
            this_mask = np.zeros(self.imsz)
            if cumBins:
                this_bin = (self.mask_by_bin <= i+1) # Boolean indexing
            else:
                this_bin = (self.mask_by_bin == i+1) # Boolean indexing
            this_mask[this_bin] = 1
            mask = this_mask * self.intrinsic_mask
            self.mask = mask.astype(np.float64)
            self.mybin = i # Bookkeeping, JIC; FFTs of masked images have associated bin number...
            self._A12_2D_at_Bin(cross=cross)
            ### Now compute the Fourier transforms of the image(s) and mask.

    def _A12_2D_at_Bin(self,cross=False):
        
        ### Compute the Fourier transforms of the image(s) and mask.
        ### In principle, we are saving doing this Fourier transform at each k_r, for a given bin.
        if self.img2 is None or (cross == False):
            self._f_I2 = None
        else:
            self._f_I2   = np.fft.fft2(self.img2*self.mask)
        self._f_I = np.fft.fft2(self.img*self.mask) # FFT of the (masked) image
        self._f_M = np.fft.fft2(self.mask)  # FFT of the mask       

        self._N = self.mask.size
        self._M = self.mask.sum()
        
        for ii, k_r in enumerate(self.A12_kn):
            if k_r == 0:
                continue
            else:
                self._k_r = k_r
                self.A12_pk[ii,self.mybin] = self._A12_2D_at_k_r()
            
    def _A12_2D_at_k_r(self,eps=1.0e-3,verbose=False):
        """ 
        [verbose]- have the function say more things to you.
        [eps]    - epsilon; relates to scaling/separation of the two sigmas. Arevalo+ (2012) liked the value 
               of 1e-3, though one can change this. We're happy to keep with 1e-3.
        
        """

        # Compute sigmas (in the same units as pixsize is defined, e.g. arcseconds)
        sig    = 1./(np.sqrt(2.*np.pi**2)*self._k_r)
        sig1   = sig/np.sqrt(1. + eps)
        sig2   = sig*np.sqrt(1. + eps)
        smoothk1 = np.exp(-2*self.k_mat**2*np.pi**2 * (sig1)**2)
        smoothk2 = np.exp(-2*self.k_mat**2*np.pi**2 * (sig2)**2)
        g1_I = np.real(np.fft.ifft2(self._f_I*smoothk1))
        g2_I = np.real(np.fft.ifft2(self._f_I*smoothk2))
        g1_M = np.real(np.fft.ifft2(self._f_M*smoothk1))
        g2_M = np.real(np.fft.ifft2(self._f_M*smoothk2))
                        
        mone = (self.mask > 0.0) # Allows for Boolean indexing; avoids division by zero
        if self._f_I2 is None:
            ###################  Calculate the autocovariance (auto power spectrum) ######################
            Delt = np.zeros(g1_I.shape)                            
            Delt[mone] = (g1_I[mone]/g1_M[mone] - g2_I[mone]/g2_M[mone]) # Avoid divide by zero
            Df = Delt*Delt*self.mask                                     # Avoid divide by zero
        else:
            g1_I2 = np.real(np.fft.ifft2(self._f_I2*smoothk1))
            g2_I2 = np.real(np.fft.ifft2(self._f_I2*smoothk2))
            ###################  Calculate the cross-covariance (cross power spectrum) ######################
            Delt1 = np.nan_to_num(np.divide(g1_I,g1_M))  - np.nan_to_num(np.divide(g2_I,g2_M))
            Delt2 = np.nan_to_num(np.divide(g1_I2,g1_M)) - np.nan_to_num(np.divide(g2_I2,g2_M)) 
            Df = Delt1*Delt2*self.mask # Arguably self.mask**2, but 1**2 = 1 and 0**2 = 0. So. Save some computation.
        S2_kr = (self._N/self._M) * np.mean(Df) # A12 paper would use mean. 

        gamf   = np.pi # Can change for different dimensionality. But this function is specifically for 2D
        P_kr   = S2_kr /(eps**2 * gamf * self._k_r**2) # this is intrinsic PS(k)

        return P_kr

class ImagesFromPS:

    def __init__(self,nPix=1024,pixSize=1.0,slope=0.0,kc=1e-3,p0=1e0,kdis=1e3,eta_c=4.0,eta_d=1.5,minfactor=1e2,
                 seed=None):
        """
        All wavenumber values (kc, kdis, k) should match those for the inverse of the units of pixsize.
        For example, if pixsize=1.0 means that each pixel is 1 kpc on a side, then the corresponding k-values
        should denote inverse kpc units.
        
        """

        ### Corresponding to a paremeterized power spectrum
        self.set_PS_parameters(slope=slope,kc=kc,p0=p0,kdis=kdis,eta_c=eta_c,eta_d=eta_d)

        ### Corresponding to the map (image).
        self.set_Image_size(nPix,pixSize)

        ### To control for numerical accuracy
        self.set_minfactor(minfactor)

        self.rng = np.random.default_rng(seed=seed)
        
    def set_PS_parameters(self,slope=0.0,kc=1e-3,p0=1e0,kdis=1e3,eta_c=4.0,eta_d=1.5):
        self.slope=slope   # Power-law slope (k**slope)
        self.kc = kc       # Cutoff scale
        self.p0 = p0       # Normalization
        self.kdis = kdis   # Disipation scale
        self.eta_c = eta_c # Cutoff exponent
        self.eta_d = eta_d # Dissipation exponent
        
    def set_minfactor(self,minfactor):

        self.minfactor = minfactor # If min(k)==0, replace with smallest non-zero k divided by this factor        
        
    def set_Image_size(self,nPix,pixSize):

        self.nPix = nPix
        self.pixSize = pixSize        
        k,dkx,dky = get_freqarr_2d(nPix, nPix, pixSize, pixSize)
        kflat = k.flatten()
        gki = (kflat > 0)
        gk = kflat[gki]
        self.kflat = kflat
        self.k = gk
        self.gki = gki

    def get_parameterized_PS(self,k):

        keqz = (k == 0)
        kgtz = (k > 0)
        kmin = np.min(k[kgtz])
        if np.sum(keqz) > 0:
            k[keqz] = kmin/self.kfactor # Avoid k=0, but get a really small value.
        P3D  = self.p0*k**(self.slope) * np.exp(-(self.kc/k)**self.eta_c) * np.exp(-(k/self.kdis)**self.eta_d)

        return np.nan_to_num(P3D)

    def get_logspaced_k(self,kmin=None,kmax=None,nPts=500):

        mykmin = 1.0/(self.nPix * self.pixSize) if kmin is None else kmin
        mykmax = 1.0/(self.pixSize) if kmax is None else kmax
        k = np.logspace(np.log10(mykmin),np.log10(mykmax),nPts)

        return k

    def set_seed(self,seed):

        self.rng = np.random.default_rng(seed=seed)
    
    def generate_realization(self,k_in=None,PS_in=None,seed=None):

        psarr = self.kflat*0
        if k_in is None or PS_in is None:
            psout = self.get_parameterized_PS(self.k)
        else:
            psout = np.exp(np.interp(np.log(self.gk),np.log(k_in),np.log(PS_in)))
        psarr[self.gki] = psout
        ps2d = psarr.reshape(self.nPix,self.nPix) * self.nPix * self.nPix

        if seed is not None:
            self.set_seed(seed)
        phase = self.rng.uniform(size=(self.nPix,self.nPix))*2*np.pi
        newfft = np.sqrt(ps2d) * np.exp(1j*phase)
        img = np.real(np.fft.ifft2(newfft/self.pixSize))
        img *= np.sqrt(2.0)

        return img

#################################################################################
    
def get_freqarr_2d(nx, ny, psx, psy):
    """
       Compute frequency array for 2D FFT transform

       Parameters
       ----------
       nx : integer
            number of samples in the x direction
       ny : integer
            number of samples in the y direction
       psx: integer
            map pixel size in the x direction
       psy: integer
            map pixel size in the y direction

       Returns
       -------
       k : float 2D numpy array
           frequency vector
    """
    kx =  np.outer(np.fft.fftfreq(nx),np.zeros(ny).T+1.0)/psx
    ky =  np.outer(np.zeros(nx).T+1.0,np.fft.fftfreq(ny))/psy
    dkx = kx[1:][0]-kx[0:-1][0]
    dky = ky[0][1:]-ky[0][0:-1]
    k  =  np.sqrt(kx*kx + ky*ky)
    #print('dkx, dky:', dkx[0], dky[0])
    return k, dkx[0], dky[0]

class MultiGaussBeam:

    def __init__(self,norms,widths):
        """
        Define a beam (or point-spread function, PSF) as multiple Gaussians via a list of
        normalizations (height) and widths (Gaussian sigmas).

        Parameters
        ----------
        norms : %(dtypes)s
            array-like collection of Gaussian normalizations.
            Internally, the sum of norms will be normalized to equal unity
        widths : %(dtypes)s
            array-like collection of Gaussian standard deviations.
        """
        self.norms = np.array(norms,dtype=float)
        self.norms /= np.sum(self.norms) # Impose unitary normalization
        self.widths = np.array(widths,dtype=float)
        self.nGauss = len(widths)

    def calc_FT_at_k(self,k):
        
        g = np.zeros(k.shape)    
        for n,s in zip(self.norms,self.widths):
            t = 2 * np.pi**2 * s**2
            g += n * np.exp(-k**2 * t)
        
        return g

    def calc_PS_at_k(self,k):
        """
        Compute the power spectrum for a multi-Gaussian Point Spread Function
        """
        PSF_FT = self.calc_FT_at_k(k)

        return PSF_FT**2
    
    def get_multiGauss_terms(self,karr,index):
        """

        This corrects for the bias noted in Romero+ 2023, Romero 2024.
        Code assumes nGauss are few (such that for-loops are cheap); could be optimized if nGauss is
        huge (but you've probably done something wrong to have nGauss that large).

        Parameters
        ----------
        karr : %(dtypes)s
            A one-dimensional array of wavenumbers (e.g. inverse arcseconds). The units of karr must be
            the inverse of the units used for the sigma(s) describing the N-Gaussian (below).
        index : float 
             The spectral index assumed. [Equivalent to alpha in get_multiGauss_bias()]
        """
    
        ndim = 2
        expo = (ndim/2 + 2 - index/2)

        kshape = karr.shape
        if len(kshape) > 1:
            raise IndexError("karr Must be one-dimensional")

        corrs = np.zeros(kshape[0])

        for norm1,sig1 in zip(self.norms,self.widths):
            k1 = 1.0/(np.sqrt(2)*np.pi*sig1)
            x1 = k1/karr
            n1 = norm1 * np.ones(kshape[0])
            for norm2,sig2 in zip(self.norms,self.widths):
                k2 = 1.0/(np.sqrt(2)*np.pi*sig2)
                x2 = k2/karr
                n2 = norm2 * np.ones(kshape[0])

                coef = n1*n2
                nume = (2*x1**2 * x2**2 + x1**2 + x2**2)
                deno = 2.0*x1**2 * x2**2

                term = coef * (nume/deno)**(-expo)
                corrs += term

        return corrs

    def get_multiGauss_bias(self,karr,alpha,ignPSF=False,PBonly=False):

        """
        Corrects for:
        (1) The scalar bias induced by Arevalo+ 2012
        (2) The non-scalar bias induced by a beam *and* use of Arevalo+ 2012
        --- In order for this to be done, some spectral index, alpha MUST be assumed! ---
        --- where P(k) = P0 * k**-alpha                                              ---
        Note that there is a correction for the power spectrum of the beam (PSF) within THIS term.
        If you want to correct for the PSF and the bias then these terms cancel! In light of this,
        I've added a keyword to allow you to ignore the PS term.
        ---------------------------------------------------------------------------------
        karr :%(dtypes)s
            The array of k (wavenumber) values at which to calculate the total bias
        alpha : float 
            The assumed spectral index (convention given above)
        ignPS : bool
            As mentioned above, allows you to ignore the PSF power spectrum term with respect
            to this bias. Given that you want to correct for the PSF power spectrum, they will
            cancel each other out when correcting your measured power spectrum. You can bypass
            the additional calculations by ignoring the PSF term here.
        PBonly : bool
            PSF BIAS only. That is, ignore the scalar bias due to an underlying power-law.
        """
        ndim = 2
        lilg = (ndim/2 + 2 - alpha/2)
    
        p1 = 2**(alpha/2)
        p2 = self.get_multiGauss_terms(karr,alpha)
        p3 = sps.gamma(lilg) / sps.gamma(ndim/2 + 2)
        PSF_ps = 1.0 if ignPSF else self.calc_PS_at_k(karr)

        bias  = p2/PSF_ps if PBonly else p1*p2*p3 / PSF_ps

        return bias

