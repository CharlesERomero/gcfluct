import numpy as np
import scipy.constants as spconst
from scipy.interpolate import interp1d
# Now various astropy modules
from astropy.io import fits
from astropy import wcs   
import astropy.units as u
import astropy.constants as const
from astropy.coordinates import Angle #
from astropy.cosmology import FlatLambdaCDM
cosmo = FlatLambdaCDM(H0=70.0, Om0=0.3, Tcmb0=2.725)

# Now project/repo modules
import UtilityFunctions as UF
import numerical_integration as ni
import tSZ_spectrum as tsz
import kSZ_spectrum as ksz

class Cluster:

    def __init__(self,z,m500=None,r500=None):
        self.z = z
        self.d_ang = get_d_ang()
        self.dens_crit = cosmo.critical_density(z)
        self.h70 = (cosmo.H(0) / (70.0*u.km / u.s / u.Mpc))
        self.h = cosmo.H(z)/cosmo.H(0) # Sometimes called E in the literature.

        if not m500 is None:
            self.m500 = m500
            self.r500 = r500_from_m500()
        else:
            if R500 is None:
                raise TypeError("No M500 or R500 specified.")
            else:
                self.R500 = R500
                self.M500 = M500_from_R500()

        self.Ang500 = Theta500_from_M500()  #R500 on the sky (in angular units)
        self.arcminutes500 = self.ang500 * 60 * 180 / np.pi # And in arcseconds
        arcseconds500 = self.arcminutes500 * 60
        self.scale = self.r500.to("kpc").value / arcseconds500 # kpc / arcsecond

    def M500_from_R500(self):

        M500 = (4*np.pi/3)* self.dens_crit * self.R500**3 * 500
        M500 = M500.to("M_sun")

        return M500

    def get_d_ang(self):
        """
        Calculates the angular distance from the redshift.
        """

        d_ang = cosmo.comoving_distance(self.z) / (1.0 + self.z)

        return d_ang
        
    def Theta500_from_M500(self):
    
        r500ang   = (self.R500/self.d_ang).decompose()
    
        return r500ang.value

    def P500_from_M500(self):
        P500 = (1.65 * 10**-3) * ((E)**(8./3)) * ((
            M500 * h70)/ ((3*10**14 * h70**(-1)) * const.M_sun)
            )**(2./3+0.11) * h70**2 * u.keV / u.cm**3
        return P500
                
    def R500_from_M500(self):

        R500 = (3 * self.M500/(4*np.pi * 500 * self.dens_crit))**(1./3)
        return R500

    def m2r_delta(self,mass=None,delta=500):

        M_delta = self.M500 if mass is None else mass * u.Msun
        R_delta = (3 * M_delta/(4 * np.pi  * delta * self.dens_crit))**(1/3.)
        R_delta = R_delta.to('kpc').value

        return R_delta

    def r2m_delta(self,radius=None,delta=500):

        R_delta = self.R500 if radis is None else radius*u.kpc
        M_delta = 4 * np.pi / 3 * (R_delta)**3 * delta * self.dens_crit
        M_delta = M_delta.to('M_sun').value

        return M_delta

    def mdelta_from_ydelta(self,y_delta,delta=500,ycyl=False):
        """
        Basically just a repository of Y-M relations.
        
        """
        d_a = self.d_ang.to('Mpc').value
        iv = self.h**(-1./3)*d_a
        myYdelta = y_delta * (iv**2)
        AAA,BBB = get_AAA_BBB(self.YMrel,delta,ycyl=ycyl,h70=self.h70)
        m_delta = ( myYdelta.value / 10**BBB )**(1./AAA)

        return m_delta

    def ydelta_from_mdelta(self,m_delta,delta=500,ycyl=False):
        """
        Finds A,B (scaling law terms, in get_AAA_BBB()) and applies them.
        """

        d_a = self.d_ang.to('Mpc').value
        iv = self.h**(-1./3)*d_a
        AAA,BBB = get_AAA_BBB(self.YMrel,delta,ycyl=ycyl,h70=self.h70)
        y_delta = m_delta**AAA * 10**BBB / (iv.value**2)

        return y_delta

class SS_Model(Cluster):
    
    def __init__(self,z,M500=None,R500=None,rads=rads,YMrel='A10',npts=500,rMax=8,lgRmin=-0.5,PP="A10",
                 pixArcsec=1.0):
        """

        Parameters:
        z: 
        """
        Cluster.__init__(self,z,M500=M500,R500=R500)
        self.YMrel = YMrel

        Thom_cross = (spconst.value("Thomson cross section") *u.m**2).to("cm**2")
        mec2 = (const.m_e *const.c**2).to("keV") # Electron mass times speed of light squared, in keV
        boltzmann = spconst.value("Boltzmann constant in eV/K")/1000.0 # keV/K  
        planck = spconst.value("Planck constant in eV s")/1000.0 # keV s
        self.Pdl2y = Thom_cross*self.d_ang.to("cm")/mec2 * u.cm**3 # Scaled by angular distance
        self.P2invkpc = Thom_cross*u.kpc.to("cm") / mec2 * u.cm**3 # Scaled by 1 kpc.
        #r500, p500       = R500_P500_from_M500_z(M500,z)
        self.rMax = rMax
        self.logRmax = np.log10((rMax*self.R500/u.kpc).decompose().value) # when using kpc
        if rads is None:
            rads = np.logspace(lgRmin,log5r500,npts) * u.kpc # 1 Mpc ~ R500, usually
        self.rads = rads
        self.radians = (rads / self.d_ang).decompose().value
        self.pixrad = pixArcsec * u.arcsec.to('rad').value
        self.pixarc = pixArcsec
        ###########################################################################################
        self.set_gnfw_model() # Will assign A10 UPP pars at initialization.

    def set_gnfw_model(self,c500=1.177, p0=8.403, a=1.0510, b=5.4905, c=0.3081):
        """
        Here is a block of methods. I might want to change the functionality so that I could make a    
        Compton-y profile (set_gnfw_yprof) in one command after updating gnfw pars.                   
        I probably will just write a new method to do that.                                         
        """
        self._set_gnfw_pars()
        self.set_pressure_profile_gnfw()
        self.set_ulPprof()
        self.set_yprof()
        self.set_xyrmap()
        self.set_yMap_from_gnfw()
        self.BeamSmoothedyMaps = None # (re)set this to None; I want the user to specify smoothing kernels   
        self.BeamSmoothedyProfile = None
        
    def _set_gnfw_pars(self, c500=1.177, p0=8.403, a=1.0510, b=5.4905, c=0.3081):
        """
        The user should generally not access this by itself, as one could update the gNFW parameters without
        updating other relevant model products. set_gnfw_model() groups all the products together.
        """
        self.c500 = c500
        self.p0 = p0
        self.a = a
        self.b = b
        self.c = c
        
    def set_xyrmap(self,Nr500=3.0,cx=None,cy=None,ForceInteger=False):

        mapsize = np.round(self.Arcminutes500*2*Nr500)
        xpix = int(np.round((mapsize*60)/self.pixarc))
        ypix = int(np.round((mapsize*60)/self.pixarc))
        if cx is None:
            cx   = xpix//2 if ForceInteger else xpix/2.0
        if cy is None:
            cy   = ypix//2 if ForceInteger else ypix/2.0
        x1   = (np.arange(xpix)-cx)*self.pixarc
        y1   = (np.arange(ypix)-cy)*self.pixarc
        x    = np.outer(x1,np.ones(ypix))
        y    = np.outer(np.ones(xpix),y1)
    
        self.xymap = (x,y) # Tuple of two 2D arrays (maps)
        self.rmap = np.sqrt(x**2 + y**2)

    def set_pressure_profile_gnfw(self):

        self.pressure_prof = gnfw(self.R500,self.P500,self.rads,h70=self.h70,
                          c500=self.c500, p=self.p0, a=self.a, b=self.b, c=self.c)
    
    def gnfw_pres_radii(self,radii):

        pressure_prof = gnfw(self.R500,self.P500,radii,h70=self.h70,
                          c500=self.c500, p=self.p0, a=self.a, b=self.b, c=self.c)
        
        return pressure_prof
    
    def set_ulPprof(self):

        self.unitless_pressure_profile = (self.pressure_prof * self.Pdl2y).decompose().value

    def set_yprof(self,nR500max=5):

        self.yProf = ni.int_profile(self.radians, self.unitless_pressure_profile,self.radians,zmax=self.Ang500*nR500max)
    
    def set_yMap_from_gnfw(self):
        """
        """

        self.set_gnfw_yprof()
        flatymap = MM.grid_profile(self.radians,self.yProf,self.xymap)
        ymap = flatymap.reshape((nx,ny))
        self.yMap = ymap

    def make_gnfw_beam_smoothed(self,fwhm=10.0):
    
        yProf = self.get_gnfw_yprof()
        pixfwhm = fwhm/self.pixarc
        BeamMap = imf.fourier_filtering_2d(self.yMap,"gauss",pixfwhm)     # in Compton y
        fwhmstr = "{:.2f}".format(fwhm).replace('.','p')
        dictkey = "yMap_"+fwhmstr
        if self.BeamSmoothedyMaps is None:
            BeamSmoothedMapDict = {dictkey:BeamMap}
            self.BeamSmoothedyMaps = BeamSmoothedMapDict
        else:
            self.BeamSmoothedyMaps[dictkey] = BeamMap

    def get_gnfw_beamSmoothed_yProf(self,fwhm=10.0):
        """
        Creates a Compton-y profile of the same array size (same radii) as the unsmoothed profile,
        but for a given beam (taken as a single, circular Gaussian, characterized by its FWHM). 
        """

        fwhmstr = "{:.2f}".format(fwhm).replace('.','p')
        dictkey = "yMap_"+fwhmstr
        if self.BeamSmoothedyMaps is None:
            self.make_gnfw_beam_smoothed(fwhm=fwhm)
        else:
            if not (dictkey in self.BeamSmoothedyMaps):
                self.make_gnfw_beam_smoothed(fwhm=fwhm)
        Beam_yMap = self.BeamSmoothedyMaps[dictkey]
        rbin,ybin,yerr,ycnts = UF.bin_two2Ds(self.rmap,Beam_yMap,binsize=self.pixarc*2.0)
        fint = interp1d(rbin,ybin, bounds_error = False, fill_value = "extrapolate")
        radarcsec = self.radians * 3600 * 180/np.pi
        if self.BeamSmoothedyProfile is None:
            BeamSmoothedyProfile = {dictkey:fint(radarcsec)}
            self.BeamSmoothedyProfile = BeamSmoothedyProfile
        else:
            self.BeamSmoothedyProfile[dictkey] = fint(radarcsec)

    #####################################################################################
            
    def calculate_Y_cyl_prof(self,yprof=None) -> NDArray[np.floating]:
        """
        While the user could do their own calculations by hand, let's provide an avenue for accurate calculations.
        
        User can choose a beam-smoothed y-profile. Otherwise (if no y-profile is specified), the method will use
        the unsmoothed Compton y profile.
        
        Returns
        An array of Y_cylindrical values of the same shape as input y-profile (and shape as self.radians)
        """

        if yprof is None:
            yprof = self.yProf
        yratios = yprof[:-1] / yprof[1:]
        rratios = self.radians[:-1] / self.radians[1:]
        alpha = np.log(yratios) / np.log(rratios)
        
        parint= ((self.radians[1:])**(2.0-alpha) - (self.radians[:-1])**(2.0-alpha) ) * \
            (yprof[:-1]*(yprof[:-1]/u.rad)**alpha) / (2.0 - alpha)
        tint  = 2.0*np.pi * np.cumsum(parint) * u.sr

        Ycyl  = np.hstack([tint[0].to("arcmin2")]/10.0,tint.to("arcmin2")) # Stack to return same dimensionality

        return Ycyl

    def Y_sphere(self):
    
        pratios = self.unitless_pressure_profile[:-1] / self.unitless_pressure_profile[1:]
        rratios = self.radians[:-1] / self.radians[1:]
        alpha = np.log(pratios) / np.log(rratios)
     
        parint= ((self.rads[1:]/u.kpc)**(3.0-alpha) - (self.rads[:-1]/u.kpc)**(3.0-alpha) ) * \
            (self.unitless_pressure_profile[:-1]*(self.rads[:-1]/u.kpc)**alpha) / (3.0 - alpha)
        tint  = 4.0*np.pi * np.cumsum(parint) * (u.kpc)**2

        Ysphere = np.hstack([tint[0].to("Mpc2")]/10.0,tint.to("Mpc2"))
    
        return Ysphere

    def _set_xr_UniversalBetaPars(self,SoftOnly=True):
       
        beta = 2.0/3.0
        x = 0.1
        self.xr_r_c = x * self.R500
        theta_c = x * self.Ang500 *60 * 180 / (D_a_mpc * np.pi) # arcminutes
        if SoftOnly:
            Universal_I = 5.9e-4 / (u.Mpc)
            Zscale = self.R500*self.E**2 / (1 + z)**3
        else:
            Universal_I = 7.7e-4 / (u.Mpc**2)
            Zscale = self.R500**2 * self.E**(7.0/6.0) / (1 + self.z)**3
            I_xscale = (2*np.pi * x**2 * (np.sqrt(1+x**2) - 1)) / (np.sqrt(1+x**2))
            I_not = (Universal_I * Zscale / I_xscale).decompose().value

        self.xr_I_0 = I_not
        self.xr_theta_c = theta_c
        self.xr_beta = beta

    def set_xr_USBP(self,SoftOnly=True):
    
        radarcmins = self.radians * 60 * 180/np.pi
        self._set_xr_UniversalBetaPars(SoftOnly=SoftOnly)  # rc in arcminutes
        sbprof = self.xr_I_0 / ( (1 + (radarcmins/self.xr_theta_c)**2)**(3*self.xr_beta - 0.5) )
    
        self.xr_sb_prof = sbprof

##########################################################################################################################
######                                                                                                               #####
######        Functions that contain relations from the literature or otherwise not tied to objects                  #####
######                                                                                                               #####
##########################################################################################################################

def get_cosmo():

    return cosmo

def gnfw(R500, P500, radii, c500= 1.177, p=8.403, a=1.0510, b=5.4905, c=0.3081,h70=1.0):


    P0 = P500 * p * h70**-1.5
    rP = R500 / c500
    rf =  (radii/rP).decompose().value
    result = (P0 / (((rf)**c)*((1 + (rf)**a))**((b - c)/a)))

    return result

def get_AAA_BBB(YMrel,delta,ycyl=False,h70=1.0):
    """
    Basically just a repository of Y-M relations.
    YMrel must be either:
       (1) 'A10' (Arnaud 2010)
       (2) 'A11' (Anderson 2011)
       (3) 'M12' (Marrone 2012)
       (4) 'P14' (Planck 2014), or
       (5) 'P17' (Planelles 2017)

    All are converted to Y = 10^BBB * M^AAA; mass (M) is in units of solar masses; Y is in Mpc^2 (i.e. with D_A^2 * E(z)^-2/3)
    
    """

    if delta == 2500:
        if YMrel == 'A10':
            AAA    = 1.637;   BBB = -28.13  # From Comis+ 2011
        #if ycyl:
        #    AAA = 1.60;   BBB = -27.4   # From Comis+ 2011
        if YMrel == 'A11':
            AAA    = 1.637;   BBB = -28.13  # From Comis+ 2011
        #if ycyl:
        #    AAA = 1.60;   BBB = -27.4   # From Comis+ 2011
        elif YMrel == 'M12':
            #BBB = -29.66909090909 ???
            BBB = -30.669090909090908
            AAA = 1.0 / 0.55
        elif YMrel == 'M12-SS':
            BBB = -28.501666666666667
            AAA = 5.0/3.0
        elif YMrel == 'P14':
            AAA = 1.755          #### NOT PLANCK!!!
            BBB = -29.6833076    # -4.585
        elif YMrel == 'P17':     # Planelles 2017
            AAA = 1.755
            BBB = -29.6833076    # -4.585
        elif YMrel == 'H20':     #### NOT He et al. 2020!!!
            AAA = 1.755
            BBB = -29.6833076    # -4.585
        else:
            print('using Comis+ 2011 values')
            
    elif delta == 500:
        if YMrel == 'A10':
            AAA   = 1.78
            Jofx  = 0.7398 if ycyl else 0.6145  # Actually I(x) in A10, but, it plays the same role, so use this variable
            #print(Jofx,' ycyl: ',ycyl)
            Bofx  = 2.925e-5 * Jofx * h70**(-1) / (3e14/h70)**AAA
            #BBB = np.log10(Bofx.value)
            BBB = np.log10(Bofx)
        if YMrel == 'A11':
            Btabulated = 14.06 # But this is some WEIRD Y_SZ (M_sun * keV) - M relation
            Bconversion = -18.855
            Aconversion = -24.176792495381836
            AAA    = 1.67;   BBB = Btabulated + Bconversion + Aconversion  # Anderson+ 2011, Table 6
        #if ycyl:
        #    AAA = 1.60;   BBB = -27.4   # From Comis+ 2011
        elif YMrel == 'M12':
            #BBB = -30.66909090909 # BBB = -16.567
            BBB = -37.65227272727
            AAA = 1.0 / 0.44
        elif YMrel == 'M12-SS':
            BBB = -28.735
            AAA = 5.0/3.0
        elif YMrel == 'P14':
            AAA = 1.79
            BBB = -30.6388907    # 
        elif YMrel == 'P17':
            AAA = 1.685
            BBB = -29.0727644    # -4.585
        elif YMrel == 'H20':
            AAA = 1.790
            BBB = -30.653047     # -4.739
        else:
            print('Woops')
    else:
        import pdb;pdb.set_trace()

    return AAA,BBB

def _get_YM_sys_err(logy,YMrel,delta=500,ySph=True,h70=1.0):

    if delta == 500:
        if YMrel == 'A10':
            pivot = 3e14; Jofx  = 0.6145 if ySph else 0.7398
            Norm  = 2.925e-5 * Jofx * h70**(-1); PL = 1.78
            #t1   = ((logy - 1)/PL )*0.024
            t1   = 0.024 / PL
            t2   = ((np.log10(Norm) - logy)/PL**2)*0.08
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            #import pdb;pdb.set_trace()
        elif YMrel == 'A11':
            t1   = 0.29 # Fixed slope
            t2   = 0.1
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            print(xer)
        elif YMrel == 'M12':
            t1   = np.array([1.0,logy+5])
            #t1   = np.array([0.367,0.44])
            tcov = np.array([[0.098**2,-0.012],[-0.012,0.12**2]])
            #tcov = np.array([[0.098**2,-(0.012**2)],[-(0.012**2),0.12**2]])
            #tcov = np.array([[0.098**2,0],[0,0.12**2]])
            t2   = np.abs(np.matmul(t1,np.matmul(tcov,t1)))
            xer  = np.sqrt(t2) * np.log(10)
            print(xer)
        elif YMrel == 'M12-SS':
            t1   = 0.0 # Fixed slope
            t2   = 0.036
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            print(xer)
        elif YMrel == 'P14':
            t1   = 0.06
            t2   = 0.079
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            print(xer)
        elif YMrel == 'P17':
            Norm = -4.305; PL = 1.685
            t1   = 0.009 / PL
            t2   = ((Norm - logy)/PL**2)*0.013
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            #xer = 0.104
        elif YMrel == 'H20':
            pivot = 3e14; 
            Norm  = 10**(-4.739); PL = 1.79
            #t1   = ((logy - 1)/PL )*0.024
            t1   = 0.003 / PL
            t2   = ((np.log10(Norm) - logy)/PL**2)*0.015
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
        else:
            print('No match!')
            import pdb;pdb.set_trace()
    elif delta == 2500:
        if YMrel == 'A10':
            #LogNorm = -28.13; PL = 1.637
            #t1   = 0.88 / PL 
            #t2   = ((logy - LogNorm)/PL**2)*0.062
            #xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            xer  = np.log(1 + 0.23)
        elif YMrel == 'A11':
            t1   = 0.29 # NOT CORRECT! TAKEN FROM DELTA=500!!!
            t2   = 0.1  # NOT CORRECT! TAKEN FROM DELTA=500!!!
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            print(xer)
        elif YMrel == 'M12':
            t1   = np.array([1.0,logy+5])
            #t1   = np.array([0.367,0.44])
            #tcov = np.array([[0.063**2,-0.008],[-0.008,0.14**2]])
            tcov = np.array([[0.063**2,-(0.008**2)],[-(0.008**2),0.14**2]])
            #tcov = np.array([[0.098**2,0],[0,0.12**2]])
            t2   = np.abs(np.matmul(t1,np.matmul(tcov,t1)))
            xer  = np.sqrt(t2) * np.log(10)
            print(xer)
        elif YMrel == 'M12-SS':
            t1   = 0.0 # Fixed slope
            t2   = 0.033
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            print(xer)
        elif YMrel == 'P14':
            t1   = 0.06  ### M500 numbers
            t2   = 0.079
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            print(xer)
        elif YMrel == 'P17':
            Norm = -4.5855; PL = 1.755
            t1   = 0.014 / PL
            t2   = ((Norm - logy)/PL**2)*0.020
            xer  = np.sqrt(t1**2 + t2**2) * np.log(10)
            #xer = 0.104
        elif YMrel == 'H20':
            xer  = np.log(1 + 0.23) ## B/C why not
        else:
            print('No match!')
            import pdb;pdb.set_trace()
    else:
        print('No match for delta!')
        import pdb;pdb.set_trace()

    return xer


